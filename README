== TOGoS's Minecraft Map Generator ==

TOGoS's Minecraft Map Generator (TMCMG) is a Java application for
generating terrain data (chunk files) for Minecraft Alpha based on
user-defined terrain functions.  It includes a GUI for previewing
the generated terrain before exporting it, and can also be run from
the command-line.



== GUI Notes ==
=== World Preview ===

This window shows side and top views of the terrain resulting from
interpreting the loaded script.  You can move around using the arrow
keys and zoom in and out using plus and minus.  For now this shows
only base terrain--no chunk-based objects such as trees or grass will
appear in the preview.  The number next to "MPP" near tht bottom
indicates Meters Per Pixel.

=== Export Chunks ===

This window pops up when you select Export Chunks under the File menu.
To select an output directory (this should be a directory directly
under 'saves/' for SP data), you must browse to that directory and
select a file directly within that directory, such as 'level.dat'.

The 4 boxes under the output directory selection are to give the
X and Z coordinates of the northeastern-most corner and the width and
height of the area to generate.  X, Z, width, and depth are all in terms
of chunks, which are 16 blocks (16 meters) on a side.

When you hit 'Generate' it will start generating new data for
those chunks and writing them into the chosen output directory.
WARNING: THIS WILL OVERWRITE ANY EXISTING TERRAIN/BUILDINGS/OBJECTS
IN THE AREA, so either back up your data before generating, or only generate
on maps that have nothing you want to keep.

There's an experimental job system for exporting chunks that can be
enabled at any time (even while an export is in progress) by checking
the 'Use job system' checkbox.  In the future this may be able to take
advantage of spare computers, but for now is limited to the number of
CPUs on your PC as returned by Runtime.getRuntime().availableProcessors().

== TOGoS Noise Language ==

TOGoS Noise Language (TNL) is the language for defining terrain
generation functions.  TNL files contain any number of named expression
definitions and one non-named expression that will be used when generating
terrain.  Expressions can refer to named expressions defined earlier using
their name.  See scripts/example.tnl for an example script using many
different predefined and user-defined functions.

=== Noise Functions ===

+, -, *, / (<expr1>,<expr2>,...)
  - add, subtract, multiply, and divide outputs of at least 2
    functions.  These can be written using infix notation, where
    standard precedence rules apply.  e.g.  the following 3
    expressions are equivalent:
    
      a - b + c * d / e
      a - (b + ((c * d) / e)) 
      -( a, +(b, /( *(c, d), e)))

==, !=, >, <, >=, <= (<expr1>,<expr2>)
  - Compare value of <expr1> and <expr2>; returns 1 when true,
    0 when false.  Can be used with if(...) or in arithmetic
    expressions.  Can be written using infix notation.
    
      == equal            ;  3 == 3
      != not equal        ;  1 != 2
      >  greater          ;  5 >  4
      <  less             ; -3 < -2
      >= greater or equal ;  1 >= 1
      <= less or equal    ;  1 <= 3

sin( <expr> ) - sine
cos( <expr> ) - cosine
atan( <expr> ) - arctangent
sqrt( <expr> ) - square root

perlin( <x>, <y>, <z> )
  - A function for generating smooth noise closely based on Ken Perlin's
    Improved 3D noise function.  The range of this function is -1 to +1
    and output is 0 at integer coordinates, so for example to create
    rolling hills using a single perlin noise function you should multiply
    the output by half the desired height between hilltops and valley floor
    and divide the inputs by the desired average distance between hills
  - e.g. 8 * perlin( x / 20, y / 20, z / 20 )
    would result in hills about 20 meters apart and 16 meters from top to
    base.
  - perlin with no arguments is equivalent to perlin( x, y, z )
  - See http://en.wikipedia.org/wiki/Perlin_noise

simplex( <x>, <y>, <z> )
  - A bit like perlin noise, but based on a triangular grid, so in
    theory is somewhat faster and has less noticable directional artifacts.
  - The implementation used by TMCMG seems to have lower average amplitude
    than perlin noise, so you may want to multiply the output more to get
    a similar effect.
  - simplex with no arguments is equivalent to simplex( x, y, z )
  - See http://en.wikipedia.org/wiki/Simplex_noise

translate-in( <xt>, <yt>, <zt>, <expr> )
  - fast input translation; xt, yt, and zt must all be constant
  - <expr> is evaluated with (x,y,z) = (x + <xt>, y + <yt>, z + <zt>)

scale-in( <xs>, <ys>, <zs>, <expr> )
  - fast input scaling; xs, ys, and zs must all be constant
  - <expr> is evaluated with (x,y,z) = (x * <xs>, y * <ys>, z * <zs>)

xf( <xt>, <yt>, <zt>, <expr> )[x,y,z] -> value
  - arbitrarily transform inputs to expr
  - <expr> is evaluated with (x,y,z) = (<xt>, <yt>, <zt>)

ridge( <min>, <max>, <expr> )
  - transforms the output of <expr> by folding it back and forth
    between <min> and <max> (which may be complex expressions
    themselves) until it lies between <min> and <max>.  e.g.
    
      ridge( 2, 4, -1 ) = 3
    
    (to calculate by hand, 2 - -1 = 3, 2 + 3 = 5, 5 - 4 = 1, and
    4 - 1 = 3).

min( <expr1>, <expr2>, ... )
  - returns the lowest value returned by any of the component
    expressions at each input point. 

max( <expr1>, <expr2>, ... )
  - returns the highest value returned by any of the component
    expressions at each input point. 

fractal( <iter>, <hscale>, <vscale>, <ihscale>, <ivscale>,
    <ztrans>, <expr> )
  - Scales inputs to and outputs from <expr> over multiple iterations,
    summing the results.
  - All parameters except <expr> must be constant
  - iter = number of iterations
  - hscale = horizontal scale (inputs will be divided by this) on
    first iteration
  - vscale = vertical scale (output will be multiplied by this) on
    first iteration
  - ihscale = how much to multiply hscale between iterations
  - ivscale = how much to multiply vscale between iterations
  - ztrans = how much to translate z for each iteration

if( <cond1>, <res1>, <cond2>, <res2>, ..., <default> )
  - Where the result of <cond1> is true, result is determined <res1>, etc.
  - If no listed conditions are true, result is determined by <default>

=== Other Functions ===

To define a world in Minecraft, you need more than a simple
[x,y,z] -> value function!  You also need to define what materials
go where, how to distribute objects such as trees, and what other
post-processing steps to perform on chunks before they are saved.

Here is a description of some of the functions that help accomplish
that:

layered-terrain( <layer1>, <layer2>, ...,
    <processor1>, <processor2>, ... )
  - defines a world generator that generates terrain based on a list
    of ground material layers and chunk processors.
  - when layers of material overlap, later layers' materials override
    those of earlier layers.  For instance if the first layer at a given
    point on the map is water (material) from 0 (floor) to 64 (ceiling),
    and the second layer is bedrock from 0 to 1, the bedrock will
    replace the water in the bottommost block at that point.

layer( <material-id>, <floor-height>, <ceiling-height> )
  - define a material layer for use with layered-terrain
  - material-id is a constant integer representing the material to be
    placed.  This can be a named material in the 'materials'
    namespace, such as 'materials.sand' (without the quotes).
  - floor-height and ceiling-height can be [x,y,z] -> value functions
    that give the height at any x, z position on the map.  x,z map
    coordinates become the x and y inputs - the z input to the
    height function will always be zero.

=== User-defined macros ===

You may define macros to use later in your script.
User-defined macros may take any number of arguments.

  mymacro( myarg ) = myarg + xf( x / 10, y / 10, z / 10, myarg );

  mymacro( simplex * 3 )
  
The above expression is equivalent to

  (simplex * 3) + xf( x / 10, y / 10, z / 10, (simplex * 3) );

Argument names may not conflict with names of macros or other arguments
already defined within the same dynamic scope:

  foo( arg ) = arg * 2;
  bar( arg ) = arg * 3;
  
  quux = foo( 10 ) + bar( 10 ); # This is OK
  quuux = foo( bar( 10 ) ); # Not OK; bar's arg conflicts with foo's.  

I plan to eventually make arguments lexically scoped, so don't rely
on programs like the following compiling:

  foo = arg * 2;
  bar( arg ) = foo * 3;
  quux = bar( 4 ); # = 20

=== Chunk post-processors ===

These are applied to chunks after all material layers:

grassifier
  - adds grass to the topmost block if it is dirt

winterizer( winterness-function )
  - if topmost block is water, turns it to ice, otherwise adds a layer of
    snow above it wherever winterness-function returns > 0

lighter
  - attempts (it's currently not completely correct) to initialize
    proper light values throughout the chunk based on shadows, water,
    etc.  It is recommended that you include this as the last component
    to layered-terrain.

flag-populated
  - sets the 'terrain populated' flag on chunks so that Minecraft does
    not try to add veins and calculate lighting itself.  Note that
    Minecraft does a MUCH better job of calculating lighting than TMCMG
    does, so you may want to leave this out unless you are very
    particular about where ores (and ash, and maybe some other stuff)
    get placed.

tree-populator( <tree-type>, <density-function> )
  - places trees at pseudo-random locations in chunks, with their
    placement being more likely where <density-function> returns
    higher values.
  - density-function = [x,y,z]->v expression giving trees per square
    meter.  As with layer height functions, the x and y inputs
    to the function come from world x and z, and the z input will
    always be zero.  The return value is interpreted as number of
    trees the populator will *attempt* to place--it may fail to place
    some if they would be put on a surface other than dirt or if
    there are obstacles that prevent them from fitting.
  - for now, <tree-type> is limited to the constants:
    tree-types.round
    tree-types.pine
  - I don't recommend using this anymore.  Just leave flag-populated
    off and let Minecraft add trees.



== Contact ==

If it doesn't work, e-mail bug reports and complaints to

  togos zero zero at gee male daught com.

You may also use the ticketing system on GitHub to request
features or add them yourself: http://github.com/TOGoS/TMCMG/
